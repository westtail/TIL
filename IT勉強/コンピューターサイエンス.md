# みんなのコンピューターサイエンス
* コンピュータサイエンス（computerscience：計算機科学）
## 基礎
### 解決案
解決案（idea）をフローチャートと擬似コードに落とし、モデルを作成する。  
タスクに対してどのように解決を行うか。
* フローチャート  
処理手順を書き表す方法
* 疑似コード  
コードによる処理手順の記載
* モデル  
対象の問題と特性を表現する概念
### 論理  
論理（logic）上の善し悪しを知る。
#### 演算子
論理式などは、TrueかFalseを表現する。論理をちゃんと利用する
* 論理変数  
事象の妥当性を表す例えば　A：プールが温かいB：私は泳ぐ、でA:Trueならプールが暖かいとなる
* 条件演算子  
変数の依存関係を表す →であわらされる　A→B：プールが温かければ、私は泳ぐとなる  
つまりA:TrueであればB:Trueである必要があり、A:FalseだとBは関係がないという関係性になる  
A→BはB→Aは必ずしも保証されていない
* 否定演算子  
明大の否定で！を利用する　!A：プールは冷たい（温かくない）
#### 対偶
「A→B」は「!B→!A」と同じである
#### 双条件
この条件を使うと、A↔B：プールが温かい場合にのみ、私は泳ぐとなる  
これはA:TrueとB:TrueまたはA:FalseとB:Falseのように両者の一致か必要である
#### 論理積、論理和、排他的論理和
* 論理積AND  
全ての命題がTrueの表現
* 論理和OR  
いずれかの命題がTrueの表現
* 排他的論理和XOR  
命題のどちらかだけの表現
#### プール代数
* 結合則  
ANDとORの並び順は変えることができる  
A AND (B AND C) ＝ (A AND B) AND C  
A OR (B OR C) ＝ (A OR B) OR C  
* 分配則  
ANDとORを分配することができる
A AND (B OR C) ＝ (A AND B) OR (A AND C)  
A OR (B AND C) ＝ (A OR B) AND (A OR C)  
* ドモルガンの法則  
以下の法則が成り立つ、ANDとORの変換が可能である
!(A AND B) ＝ !A OR !B
!A AND !B ＝ !(A OR B)
#### 真理値表
論理モデルを解析する手段
#### コンピューターでの論理
ANDゲート、ORゲート、XORゲートなどプール代数に依存して計算などを行なっている
### カウント
カウント（count）する。石橋を叩いて確率（probability）を見積もる。
* 乗算  
N*Mなどの異なる事象を両方起こる通り数
* 順列  
N! 要素を並べる順番数
* 同一要素が存在する順列  
順列と同じ要素を入れ替えても同じなのでそこを省く
* 組み合わせ  
順番が関与されない通り数
* 総和  
全ての事象の総和数
* 確立  
事象が発生する数/あり得る結果の数
* 独立事象  
それぞれの事象が関与しない事象
* 排反事象  
二つの事象が同時に起こらないこと
* 余事象  
二つの事象が全事象であるときの注目した事象の余分事象のこと
## 計算量  
* メソッド（method：手法）  
ごちゃごちゃなデータをソートするメソッドに時間を依存する。
* アルゴリズム（algorithm）  
有限の一連の演算で解決するメソッド
* 時間計算量（timecomplexity）  
ソートなどのアルゴリズムの計算にかかる時間。T(n)で表現される、これをランニングコスト  
最前　最小の演算数の場合  
最悪　最大の演算数の場合  
平均　平均的な演算数の場合  
### 時間のカウント
時間（time）計算量をカウントし、理解する。
* ソートの計算量をT(n)で表すことで要素の数でおよそどのくらいかかるかがわかる
* 非常に大きい要素数に対しては、支配項で計算をざっと行える
* 支配項  
最もNの乗数が高い物を実質的な T(n)とおける  
例 T(n)=n^2+n+3=n^2とできる  
* nに対してn^2、n^2はn^3よりも計算量は少なくなる
### O記法
計算量の増加を記法（BigO）で表現する。  
成長の程度を示す表記表で2^nはO(2^n),n^2はO(n^2),線形以下はO(n)となる  
### 指数関数
計算量が指数関数的（exponential）に増加するアルゴリズムを避ける。　
指数関数的なアルゴリズムはあまりにも急激に成長するのでPCで対処できない  
階乗時間（factorialtime）は恐ろしく時間がかかる、NP完全（NPcomplete）問題は非常に難しい
### メモリのカウント
メモリ（memory）が十分あることを確認する。  
進行中の計算を維持するにはコンピューターのメモリが必要になり、メモリは有限なので無限には計算できない  
* 空間計算量（spacecomplexity）  
アルゴリズムが必要とする作業記憶領域であり、アルゴリズムによっては作業記憶領域が足りないために、時間計算量がかかる手法を選ばないといけなくなる
## 戦略
### 反復処理（iteration）
繰り返し処理を実行する。条件が満たされるまで、for,whileなどを用いて処理を繰り返す  
全ての要素を一つずつ処理するO(n)もあれば、べき集合の計算でO(2^n)の物もある  
一般的に高速で実行されるが、複雑で理解が難しい問題がある
### 再帰処理（recursion）
エレガントに反復する。ある関数が自らのクローンに仕事をさせる仕組みを再帰  
関数Aの中で処理をして処理が残っていれば関数Aを呼び出すなど、処理が続く限り自分自身の関数を繰り返す。  
対象が小さすぎ、これ以上減らせない状態を基底状態(base case)がある  
プログラムを単純にできるものの、計算結果を文字するメモリが必要となり、関数の呼出によりCPUの使用も増える
### 総当たり攻撃(brute force)
効率が悪いが時間がある時に使用する。  
問題のあり得る解の候補を全て検査することによって問題を解く。場合によっては最前の時間計算量である時もある
### バックトラック(backtrack)
悪い選択肢を試し、引き返して計算を行う  
一つ目の処理A後にもし行き詰れば、その処理Aを取り消して、一つ目の処理を別の方法で処理をする。  
つまり、失敗するごとに一つ前に戻って処理することで、最適な解を見つける手法
### 発見的解法 (heuristic)
妥当程度で我慢して時間を節約する  
最適な解を見つける手法ではないが、ある程度の解を見つけて、時間を節約する  
* 欲張り戦略  
以前の選択に戻ることなく、各段階で最前の洗濯を試みる手法  
問題に対して、最も価値がある処理を行なっていくことが、結果的に最適な解を見つけることもある
### 分割統治法
難しい問題に利用される  
最適部分構造の問題をより小さい問題に分割し、簡単な問題にしてから解いて、大きな問題を解決する  
計算量はO(log2n)となり非常に大きなリストに対して効率の良いマージができる  
分割統治法を用いることで場合によっては計算量が減る可能性がある  
### 動的計画法
現存の問題を動的に特定し苦労するのを避ける  
繰り返し行われる部分問題を識別して、一回だけ計算するようにする  
既に計算済みの結果を保持しておくことで、計算をせずに結果だけを用いて処理ができる  
* キャッシュ、メモ化　部分計算を再利用する技法
* トップダウン 基底状態(計算できない状態)に達するまで対象データを減らす
* ボトムアップ 基底状態を計算して解放に達するまで組み立てる
### 分岐限定砲
解が広がるのを避けるため、問題の範囲を限定する
悪い選択肢を素早く特定し、破棄して処理を減らす  
* 上限 値をどれたけ高くできるかの制限
* 下限 その値として期待される最低の値
1. 問題を複数の部分問題に分割する
2. 各部分問題の上限と下限を探し出す
3. 全ての部分問題の限定を比較する
4. 最も期待できる部分問題で１に戻る
### まとめ
アルゴリズムとして分割統治法の問題を小さい問題に分割して計算する方法が効率が良い
また、繰り返しの計算になるので動的計画法で計算結果を保持して無駄な計算を行わないようにする
